"""
IO module for Conformer Routines.

Developed by Dan Burrill and Michael Taylor
"""

# Imports
import ase.io as ase_io
import shutil
import subprocess as sub
import numpy as np
import copy

import architector.io_obabel as io_obabel 
import architector.io_molecule as io_molecule
import architector.arch_context_manage as arch_context_manage
from architector.io_calc import CalcExecutor

def isint(str):
    out = False
    try:
        out = int(str)
        out = True
    except:
        out = False
    return out

# Functions
def read_conformers(fileName):
    '''
    Read conformers from file.

    Parameters
    ----------
    fileName : str
        File path to read in conformers generated by crest
    
    Returns
    ----------
    molList : list (ase.atoms.Atoms)
        Conformers read from crest as ASE atoms
    xtb_energies : list (float)
        Sorted xtb energies from the output
    '''
    # Read conformers to ASE Atoms objects
    molList = ase_io.read(fileName,index=":")

    # Center all conformer COMs at the origin
    for mol in molList:
        mol.translate(-mol.get_center_of_mass())

    with open(fileName,'r') as file1:
        lines = file1.readlines()
    xtb_energies = []
    read = False
    for line in lines:
        sline = line.split()
        if len(sline) == 1:
            is_int = isint(sline[0])
            if is_int:
                if int(sline[0]) == len(mol):
                    read=True
            elif read:
                xtb_energies.append(float(sline[0])*27.2114) # Hartee to eV
                read = False
            else:
                print('Warning - messed up!')
    return molList,xtb_energies

def crest_conformers(structure, charge=None, uhf=None,
                    solvent='none',
                    crest_options="--gfn2//gfnff --noreftopo --nocross --quick"):
    '''
    Find conformers of a given structure with CREST.

    Parameters
    ----------
    structure : ase.atoms.Atoms/str, optional
        structure passsed, default None
    charge : int, optional
        charge of the species, default None
    uhf : int, optional
        number of unpaired electrons in the system, default None
    solvent : str, optional
        whether to use a solvent for conformer evalulation, default 'none'
    crest_options : str, optional
        string of crest_options to use in crest run.

    Returns
    ----------
    conformerList : list (ase.atoms.Atoms)
        Conformers generated via crest as ASE atoms
    xtb_energies : list (float)
        List of xtb energies output from CREST
    '''

    # Convert smiles to xyz string

    crestPath = shutil.which('crest')

    mol = io_molecule.convert_io_molecule(structure)
    if charge is not None:
        mol.charge = charge
    elif mol.xtb_charge is None:
        mol.detect_charge_spin()
    mol_charge = mol.xtb_charge

    mol.swap_actinide()
    actinides = copy.deepcopy(mol.actinides)
    actinides_swapped = copy.deepcopy(mol.actinides_swapped)

    even_odd_electrons = (np.sum([atom.number for atom in mol.ase_atoms])-mol_charge) % 2
    if (uhf is not None):
        if (even_odd_electrons == 1) and (uhf == 0):
            uhf = 1
        elif (even_odd_electrons == 1) and (uhf < 7) and (uhf % 2 == 0):
            uhf += 1
        elif (even_odd_electrons == 1) and (uhf >= 7) and (uhf % 2 == 0):
            uhf -= 1
        if (even_odd_electrons == 0) and (uhf % 2 == 1):
            uhf = uhf - 1 
        elif (even_odd_electrons == 1) and (uhf % 2 == 0):
            uhf = uhf + 1
    elif mol.xtb_uhf is not None:
        uhf = mol.xtb_uhf
    else:
        uhf = 0 # Set spin to LS by default
        if (even_odd_electrons == 1) and (uhf == 0):
            uhf = 1
        elif (even_odd_electrons == 1) and (uhf < 7) and (uhf % 2 == 0):
            uhf += 1
        elif (even_odd_electrons == 1) and (uhf >= 7) and (uhf % 2 == 0):
            uhf -= 1
        if (even_odd_electrons == 0) and (uhf % 2 == 1):
            uhf = uhf - 1 
        elif (even_odd_electrons == 1) and (uhf % 2 == 0):
            uhf = uhf + 1

    mol_charge = int(mol_charge) # Ensure integers
    uhf = int(uhf)

    xyzstr = io_molecule.convert_ase_xyz(mol.ase_atoms)

    with arch_context_manage.make_temp_directory() as _:
        # Write xyz file
        with open("structure.xyz",'w') as outFile:
            outFile.write(xyzstr)

        # Run CREST
        if (uhf == 0) and (solvent == 'none'):
            execStr = "{} structure.xyz --chrg {} {} > output.crest".format(
                                                                            crestPath,int(mol_charge),crest_options)
        elif (uhf == 0) and (solvent != 'none'):
            execStr = "{} structure.xyz --chrg {} --alpb {} {} > output.crest".format(
                                                                            crestPath,int(mol_charge),solvent,crest_options)
        elif (solvent == 'none'):
            execStr = "{} structure.xyz --chrg {} --uhf {} {} > output.crest".format(
                                                                            crestPath,int(mol_charge),int(uhf),crest_options)
        else:
            execStr = "{} structure.xyz --chrg {} --uhf {} --alpb {} {} > output.crest".format(
                                                                            crestPath,int(mol_charge),int(uhf),solvent,crest_options)

        sub.run(execStr,shell=True,check=True)

        # Read conformers from file
        conformerList_temp, xtb_energies = read_conformers("crest_conformers.xyz")
        conformerList = []
        for i,conf in enumerate(conformerList_temp):
            mol.actinides = actinides
            mol.actinides_swapped = actinides_swapped
            tmol = io_molecule.convert_io_molecule(conf)
            mol.ase_atoms = tmol.ase_atoms
            mol.swap_actinide()
            conformerList.append(mol.write_mol2('Crest Conformer {}'.format(i),writestring=True))

    return conformerList, xtb_energies 

def obmol_conformers(structure,
                     charge=None,
                     uhf=0,
                     method='GFN2-xTB',
                     calculator=None,
                     relax=True,
                     obmol_total_confs=3000,
                     obmol_rmsd_cutoff=0.4,
                     obmol_energy_cutoff=50.0,
                     xtb_solvent='none',
                     neutralize=False,
                     functionalizations=None,
                     skip_spin_assign=False,
                     assembly=False,
                     parameters={}):
    '''
    Generate openbabel conforms and subsequently
    Relax/evaluate structure with xTB or whatever method requested.

    Parameters
    ----------
    structure : str/obmol/architector.io_molecule.Molecule
        smiles string for ligand
    charge : int, optional
        charge of the species, default to initial charges set on smiles
    uhf : int, optional
        number of unpaired electrons in the system, default to 0
    method : str, optional
        which gfn family method to use, default GFN2/GFNFF
    relax : bool, optional
        Relax the structure with TB method or not?, default True
    obmol_total_confs : int, optional
        Number of conformers to generate and test with openbabel, default 3000
    obmol_rmsd_cutoff : float, optional
        RMSD cutoff for classifying "new" conformers, default 0.4
    obmol_energy_cutoff : float, optional
        Energy Cutoff for considering new conformers distinct, default 50 
    xtb_solvent : str, optional
        whether to use a solvent for conformer evalulation, default 'none'
    neutralize: bool, optional
        neutralize ligand before evaluating conformers? default False.
    functionalizations : None, optional
        functionalizations option for smiles
    skip_spin_assign : bool, optional
        Skip spin assignment during TB evalulation?, default False
    parameters : dict, optional
        Parameters to pass to CalcExecutor, default {}

    Returns
    ----------
    conformerList : list (ase.atoms.Atoms)
        Conformers generated via openbabel as ASE atoms
    xtb_energies : list (float)
        List of xtb energies output 
    '''

    conf_list = io_obabel.generate_obmol_conformers(structure,
                neutralize=neutralize,
                functionalizations=functionalizations, 
                rmsd_cutoff=obmol_rmsd_cutoff,
                energy_cutoff=obmol_energy_cutoff,
                conf_cutoff=obmol_total_confs)
    
    mol = io_molecule.convert_io_molecule(structure)

    if charge:
        mol_charge = charge
    elif mol.charge != 0:
        mol_charge = mol.charge
    else:
        mol_charge = 0

    if uhf != 0:
        mol_uhf = uhf
    elif mol.uhf != 0:
        mol_uhf = mol.uhf
    else:
        mol_uhf = 0
    
    mol.charge = mol_charge
    mol.uhf = mol_uhf
    if (mol.xtb_uhf is None):
        mol.detect_charge_spin()

    conformerList_temp = []
    xtb_energies = []

    for conf in conf_list:
        tmol = io_molecule.convert_io_molecule(conf)
        mol.ase_atoms = tmol.ase_atoms
        if len(parameters) == 0:
            result = CalcExecutor(mol,
                                  method=method,
                                  calculator=calculator,
                                  xtb_solvent=xtb_solvent,
                                  relax=relax)
        else:
            result = CalcExecutor(mol,
                                  final_sanity_check=parameters['full_sanity_checks'],
                                  assembly=assembly,
                                  relax=relax,
                                  skip_spin_assign=skip_spin_assign,
                                  parameters=parameters)
        if result.successful:
            conformerList_temp.append(result.mol.write_mol2('Obmol_conformer',writestring=True))
            xtb_energies.append(result.energy)

    xtb_energies = np.array(xtb_energies)
    conformerList_temp = np.array(conformerList_temp)
    order = np.argsort(xtb_energies)

    xtb_energies = xtb_energies[order]
    conformerList = conformerList_temp[order]

    return conformerList, xtb_energies


# def add_explicit_solvents(complex_mol2string,n_solvents=6,solvent='water'):
#     """
#     THIS IS HIGHLY EXPERIMENTAL:
#     To use this xtb_IFF is needed: https://github.com/grimme-lab/xtbiff/releases/tag/v1.1 

#     We were attempting this type of solvent addition protocol:
#     https://xtb-docs.readthedocs.io/en/latest/crestqcg.html to add solvents!
#     """
    
#     if solvent in io_ptable.solvents_dict:
#         solvent_smiles = io_ptable.solvents_dict[solvent]
#     elif solvent in io_ptable.solvents_dict.values():
#         solvent_smiles = copy.deepcopy(solvent)
#         for key, value in io_ptable.solvents_dict.items():
#             if value == solvent_smiles:
#                 solvent = key
#     else:
#         raise ValueError('Crest/XTB does not know this solvent!')

#     mol = io_molecule.Molecule()
#     charge,spin = mol.read_mol2(complex_mol2string,readstring=True,read_charge_spin=True)
    
#     info_dict = dict()
#     if charge is None:
#         _,_,info_dict = io_obabel.obmol_lig_split(complex_mol2string,return_info=True)
#         charge = int(io_ptable.metal_charge_dict[info_dict['metal']] + np.sum(info_dict['lig_charges']))
#     if spin is None:
#         even_odd_electrons = (np.sum([atom.number for atom in mol.ase_atoms])-charge) % 2
#         if len(info_dict) > 1: # Check for info_dict
#             uhf = io_ptable.metal_spin_dict[info_dict['metal']]
#         else: # Otherwise calc the metal id!
#              _,_,info_dict = io_obabel.obmol_lig_split(complex_mol2string,return_info=True)
#              uhf = io_ptable.metal_spin_dict[info_dict['metal']]
#         if (even_odd_electrons == 1) and (uhf == 0):
#             uhf = 1
#         elif (even_odd_electrons == 1) and (uhf < 7):
#             uhf += 1
#         elif (even_odd_electrons == 1) and (uhf >= 7):
#             uhf -= 1
#         if (even_odd_electrons == 0) and (uhf % 2 == 1):
#             uhf = uhf - 1 
#         elif (even_odd_electrons == 1) and (uhf % 2 == 0):
#             uhf = uhf + 1
#         spin = int(uhf)

#     charge = int(charge)
#     spin = int(spin)
#     execStr = "crest solute.xyz --qcg solvent.xyz --chrg {} --uhf {} --nsolv {} --T 12 --ensemble --alpb {} --mdtime 50 --mddump 200 > crest.out".format(
#         charge,spin,n_solvents,solvent)

#     solvent_xyz_str = io_obabel.smiles2xyz(solvent_smiles)
#     solute_xyz_str = mol.write_xyz('cool.xyz',writestring=True)

#     metal_ind = [i for i,x in enumerate(mol.ase_atoms.get_chemical_symbols()) if x in io_ptable.all_metals][0]
#     coord_atoms = np.nonzero(np.ravel(mol.graph[metal_ind]))[0]
#     freeze_string = ','.join([str(x) for x in sorted(coord_atoms.tolist() + [metal_ind])])

#     molcontrol_str = """$constrain
#   atoms: {}
# $end""".format(freeze_string)

#     # os.mkdir('test') # For development
#     # os.chdir('test')

#     with arch_context_manage.make_temp_directory() as _:
#         with open('solute.xyz','w') as file1:
#             file1.write(solute_xyz_str)
#         with open('solvent.xyz','w') as file1:
#             file1.write(solvent_xyz_str)
#         with open('.xcontrol','w') as file1:
#             file1.write(molcontrol_str)
    
#     sub.run(execStr,shell=True,check=True)

#     conformerList, xtb_energies = read_conformers("final_ensemble.xyz")
        
#     return conformerList, xtb_energies

# Main (Unit Tests)
if (__name__ == '__main__'):
    # Variables
    smiles = "n1ccccc1-c2ccccn2"

    crestPath=shutil.which('crest')
    
    # Check conformers
    with arch_context_manage.make_temp_directory() as _:
        conformerList,energies = obmol_conformers(smiles,method='GFN2-xTB')

    print(conformerList)

    for idx,mol in enumerate(conformerList):
        mol.write("con_{}.xyz".format(energies[idx]))